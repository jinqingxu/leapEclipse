import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Scanner;
import java.io.File;
import java.io.FileOutputStream;

public class LeapAnalyzer {
	
	static String fileName;
	static String readFile = "/Users/irene/Documents/McGillUni/ACT_Research_Lab/Experiments/Motion Tracking Study/Experiment Data/Data from LEAP/Pid_444_Block_0_Trial_1.csv";	
	static String writePath = "/Users/irene/Documents/McGillUni/ACT_Research_Lab/Experiments/Motion Tracking Study/Experiment Data/Data from LEAP/";

	static String [] frameArray = new String[100];
	
	static int numberFrame, movementDirectionChangeX, movementDirectionChangeY, movementDirectionChangeZ;
	
	public static void main(String [] args) throws FileNotFoundException{
		
		
		loadLeapData();  // Load the LEAP motion Frame data in an array frameArray[]
		calculateNumberOfFrame();  // Count the number of frame in each trial
		calculateMovementDirectionChange();  // Count the number of time finger direction is changed towards X, Y and Z Axis
		double meanMovementError = calculateMeanMovementError();  // Calculate the Movement Error 
		calculateMovementVariability(meanMovementError);
		
		System.out.println(calculateLineDistance(0.035858475,101.11714,-98.035645, 22.076038,130.69543,-82.75954));
		
	}
	
	public static void loadLeapData () throws FileNotFoundException {
		
		Scanner s = new Scanner(new File(readFile));    // Read the Leap Data File
		String frameData;
		
		for(int i = 0; i < 5; i++){
			s.nextLine();
		}
		
		int frameArrayLength = 0;
		

		//  while(s.hasNextLine()){...} Read the frame data of a trial and store them in the frameAarray
		
		while(s.hasNextLine()){
						
			if(frameArrayLength == frameArray.length)  	// Resize frameArray [], if required
				frameArray = resize(frameArray);    // Resize the frameArray with double length
						
			frameArray[frameArrayLength] = s.nextLine();						
			frameArrayLength++;	// increment the index of the array
						
		}	// while(s.hasNextLine())
					
		frameArray = resize(frameArray, frameArrayLength);  // Resize frameArray back to frameArrayLength
				
	}
	
	// Calculates the number of Frames in a Trial
	
	public static void calculateNumberOfFrame(){
		
		numberFrame = frameArray.length;
		System.out.println(numberFrame);
		
	}
	
	// Calculates the number of time the finger changes direction towards X axis
	
	public static void calculateMovementDirectionChange(){
		
		String prevFrame [] = frameArray[0].split(",");   // First prevFrame is the 0th index (data point) of the frameArray
		String currentFrame [] = frameArray[1].split(",");	 // First currentFrame is the 1st index (data point) of the frameArray	
		
		System.out.println(prevFrame[3]);
		System.out.println(currentFrame[3]);

		float prevX = 0, prevY = 0, prevZ = 0, currentX = 0, currentY = 0, currentZ = 0;
		
		int i = 2;
		String prevDirectionX = "Right", prevDirectionY = "Up", prevDirectionZ = "Forward";
		String currentDirectionX = "", currentDirectionY = "", currentDirectionZ = "";
		
		while (i < frameArray.length){
			
			prevX = Float.parseFloat(prevFrame[3]);  // Get the X coordinate of the previous frame
			prevY = Float.parseFloat(prevFrame[4]);  // Get the Y coordinate of the previous frame
			prevZ = Float.parseFloat(prevFrame[5]);  // Get the Z coordinate of the previous frame
			
			currentX = Float.parseFloat(currentFrame[3]); // Get the X coordinate of the current frame
			currentY = Float.parseFloat(currentFrame[4]); // Get the Y coordinate of the current frame
			currentZ = Float.parseFloat(currentFrame[5]); // Get the Z coordinate of the current frame
						
			currentDirectionX = calculateMovementDirectionChangeX(prevX, currentX, prevDirectionX, currentDirectionX);
			currentDirectionY = calculateMovementDirectionChangeY(prevY, currentY, prevDirectionY, currentDirectionY);
			currentDirectionZ = calculateMovementDirectionChangeZ(prevZ, currentZ, prevDirectionZ, currentDirectionZ);
			
			prevFrame = currentFrame;   // Move to the next frame
			currentFrame = frameArray[i].split(",");  // Move to the next frame
			prevDirectionX = currentDirectionX;
			prevDirectionY = currentDirectionY;
			prevDirectionZ = currentDirectionZ;

			i++;   // change the index of frameArray to move forward
			
			
		}
		

		System.out.println(movementDirectionChangeX + " " + movementDirectionChangeY + " " + movementDirectionChangeZ);
		
	}

	
	// Calculates the number of time the finger changes direction towards X axis
	
	public static String calculateMovementDirectionChangeX(float prevX, float currentX, String prevDirectionX, String currentDirectionX){
				
		
		if(prevX != currentX){
			
			if( currentX < prevX)
				currentDirectionX = "Right";
			else
				currentDirectionX = "Left";
			
			if(!prevDirectionX.equals(currentDirectionX)){
				movementDirectionChangeX++;
				//System.out.println(prevX + " " + currentX + " " + currentDirectionX);

			}
		}   // if(prevX != currentX)

		return currentDirectionX;
	}
	
	// Calculates the number of time the finger changes direction towards Y axis
	
	public static String calculateMovementDirectionChangeY(float prevY, float currentY, String prevDirectionY, String currentDirectionY){
				
		
		if(prevY != currentY){
			
			if( currentY < prevY)
				currentDirectionY = "Down";
			else
				currentDirectionY = "Up";
			
			if(!prevDirectionY.equals(currentDirectionY)){
				movementDirectionChangeY++;
				//System.out.println(prevY + " " + currentY + " " + currentDirectionY);
			}
		}   // if(prevY != currentY)

		return currentDirectionY;
	}
	
	// Calculates the number of time the finger changes direction towards Z axis
	
	public static String calculateMovementDirectionChangeZ(float prevZ, float currentZ, String prevDirectionZ, String currentDirectionZ){
						
		if(prevZ != currentZ){
			
			if(currentZ < prevZ)
				currentDirectionZ = "Backward";
			else
				currentDirectionZ = "Forward";
			
			if(!prevDirectionZ.equals(currentDirectionZ)){
				movementDirectionChangeZ++;
				//System.out.println(prevZ + " " + currentZ + " " + currentDirectionZ);

			}
		}   // if(prevY != currentY)

		return currentDirectionZ;
	}

	// Calculates the Mean Variability (standard deviation of movement distance in each frame) of a trial
	
	public static void calculateMovementVariability(double meanMovementeError){
		
		double sumMovementErrorDifference = 0;
		double differenceMovementErrorSqr = 0;

		System.out.println(meanMovementeError);

		String firstFrame [] = frameArray[0].split(",");   // firstFrame is the starting point of the trial, which is the 0th index (data point) of the frameArray
		String lastFrame [] = frameArray[frameArray.length - 1].split(",");	 // lastFrame is the ending point of the trial, which is the length-1 index (data point) of the frameArray	

		// Get all the X-Y-Z coordinates of the starting data point (frame)
		float startX = Float.parseFloat(firstFrame[3]);
		float startY = Float.parseFloat(firstFrame[4]);
		float startZ = Float.parseFloat(firstFrame[5]);

		// Get all the X-Y-Z coordinates of the ending data point (frame)
		float endX = Float.parseFloat(lastFrame[3]);
		float endY = Float.parseFloat(lastFrame[4]);
		float endZ = Float.parseFloat(lastFrame[5]);

		for (int i = 0; i < frameArray.length; i ++){
			
			// Get all the X-Y-Z coordinates of the current data point (frame)
			String currentFrame [] = frameArray[i].split(",");
			float currentX = Float.parseFloat(currentFrame[3]);
			float currentY = Float.parseFloat(currentFrame[4]);
			float currentZ = Float.parseFloat(currentFrame[5]);
	
			differenceMovementErrorSqr = Math.pow(calculateMovementError(startX, startY, startZ, endX, endY, endZ, currentX, currentY, currentZ) - meanMovementeError, 2);
			sumMovementErrorDifference = sumMovementErrorDifference + differenceMovementErrorSqr;
		}

		double movementVariability = Math.sqrt(sumMovementErrorDifference/(frameArray.length -3));  // Remove the 1st and last frame - 1
		
		
		System.out.println(movementVariability);
		
	}
	
	
	// Calculates the Mean Movement error of a trial
	
	public static double calculateMeanMovementError (){
		
		double sumMovementError = 0;

		String firstFrame [] = frameArray[0].split(",");   // firstFrame is the starting point of the trial, which is the 0th index (data point) of the frameArray
		String lastFrame [] = frameArray[frameArray.length - 1].split(",");	 // lastFrame is the ending point of the trial, which is the length-1 index (data point) of the frameArray	

		// Get all the X-Y-Z coordinates of the starting data point (frame)
		float startX = Float.parseFloat(firstFrame[3]);
		float startY = Float.parseFloat(firstFrame[4]);
		float startZ = Float.parseFloat(firstFrame[5]);

		// Get all the X-Y-Z coordinates of the ending data point (frame)
		float endX = Float.parseFloat(lastFrame[3]);
		float endY = Float.parseFloat(lastFrame[4]);
		float endZ = Float.parseFloat(lastFrame[5]);
		
		for (int i = 0; i < frameArray.length; i ++){
			
			// Get all the X-Y-Z coordinates of the current data point (frame)
			String currentFrame [] = frameArray[i].split(",");
			float currentX = Float.parseFloat(currentFrame[3]);
			float currentY = Float.parseFloat(currentFrame[4]);
			float currentZ = Float.parseFloat(currentFrame[5]);
			

			sumMovementError = sumMovementError + calculateMovementError(startX, startY, startZ, endX, endY, endZ, currentX, currentY, currentZ);
			
		}
		
		double meanMovementError = sumMovementError/(frameArray.length - 2); // Discard the movementErrors from the start and the end point
		
		System.out.println(meanMovementError);
		
		return meanMovementError;
		
	}
	
	// Calculates the Movement error of the given frame data
	
	public static double calculateMovementError(float x1, float y1, float z1, float x2, float y2, float z2, float x, float y, float z){
		
		//double distanceLine =  Math.sqrt((Math.pow((x1-x2),2) + Math.pow((y1-y2),2) + Math.pow((z1-z2),2)));  // Find the distance of the line connecting the starting and the ending coordinates of the trial		

		double distanceLine =  calculateLineDistance(x1, y1, z1, x2, y2, z2);  // Find the distance of the line connecting the starting and the ending coordinates of the trial		
		double distancePoint = Math.sqrt(Math.pow(((x1-x) * (y2-y1) - (y1-y) * (x2-x1)), 2) + Math.pow(((y1-y) * (z2-z1) - (z1-z) * (y2-y1)), 2) + Math.pow(((z1-z) * (x2-x1) - (x1-x) * (z2-z1)), 2)) / distanceLine;
		
		//System.out.println("(" + x1 + "," + y1 + "," + z1 + ") " + "(" + x2 + "," + y2 + "," + z2 + ") " + "(" + x + "," + y + "," + z + "): " + distanceLine + " " + distancePoint);

		return distancePoint;		
		
	}
	
	// Calculate the distance of the line connecting (x1, y1, z1) and (x2, y2, z2)
	
	public static double calculateLineDistance(double x1, double y1, double z1, double x2, double y2, double z2){
				
		return  (Math.sqrt((Math.pow((x1-x2),2) + Math.pow((y1-y2),2) + Math.pow((z1-z2),2))));  
	}
	
	
	// RESIZE array "a" with double size
	
	public static String [] resize (String [] a){
		
		String [] b = new String [a.length * 2];
		
		for(int i = 0; i < a.length; i++)
			b[i] = a[i];
		
		return b;
	}
	
	// RESIZE array "a" with the given size "size"
	
	public static String [] resize (String [] a, int size){
		
		String [] b = new String [size];
		
		for(int i = 0; i < size; i++)
			b[i] = a[i];
		
		return b;
	}


}

